<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<title>Build Automation</title>
<meta name="description" content="The art of letting machines do the job for you, with Gradle as example">
<meta name="author" content="Danilo Pianini">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/reveal-js/css/reset.css">
<link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/reveal-js/css/reveal.css">
  <link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/css/custom-theme.min.1e2604bf0c24e445faa3ae7d68b2f0146c34bc9e7b9bd6aee2b7187115560e96.css" id="theme"><link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/highlight-js/default.min.css">
    
<link rel="stylesheet" href="https://gitcdn.link/repo/DanySK/css-blur-animation/master/blur.css">
<link href='https://fonts.googleapis.com/css?family=Roboto Mono' rel='stylesheet'>
<link href='https://fonts.googleapis.com/css?family=Oxygen Mono' rel='stylesheet'>
<link href='https://fonts.googleapis.com/css?family=Ubuntu Mono' rel='stylesheet'>

  </head>
  <body>
    <div class="reveal">
      <div class="slides">
  

    <section><h1 id="hahahugoshortcode-s0-hbhb">Laboratory of Software Systems</h1>
<h2 id="build-automation">Build Automation</h2>
<h3 id="danilo-pianinimailtodanilopianiniuniboit"><a href="mailto:danilo.pianini@unibo.it">Danilo Pianini</a></h3>
2020-09-25

</section><section>
<h1 id="build-automation-1">Build automation</h1>
<p>The process of automating the creation of <em>software artifacts</em>
<br/>
going from <em>source</em> code to <em>tested</em> deployable artifact</p>
<p>May include, depending on the system specifics:</p>
<ul>
<li>Automated <em>source code manipulation</em> and generation</li>
<li>Source code <em>quality assurance</em></li>
<li><em>Dependency management</em></li>
<li><em>Compilation</em>, linking</li>
<li><em>Binary manipulation</em></li>
<li><em>Test execution</em></li>
<li>Test <em>quality assurance</em> (e.g., coverage)</li>
<li>API <em>documentation</em></li>
<li><em>Packaging</em></li>
<li><em>Delivery</em></li>
</ul>
</section><section>
<h1 id="overview">Overview</h1>
<ul>
<li>Build automation: basics, styles</li>
<li>Gradle as paradigmatic build automator
<ul>
<li>Core concepts and basics</li>
<li>Dependency management and configurations</li>
<li>The build system as a dependency</li>
<li>Hierarchial organization</li>
<li>Isolation of imperativity</li>
<li>Declarativity via DSLs</li>
<li>Reuse via plug-ins</li>
<li>Testing plug-ins</li>
<li>Existing plugins</li>
</ul>
</li>
</ul>
</section><section>
<h2 id="build-automation-basics-and-styles">Build automation: basics and styles</h2>
<p>It&rsquo;s just a software that automates the building of some software
<br/>
hence, all concerns that hold for sofware creation hold for build systems creation.</p>
<p><strong>Imperative style</strong>: write a script that tells the system what to do to get
from code to artifacts</p>
<ul>
<li><em>Examples</em>: make, cmake, Apache Ant</li>
<li>Verbose, repetitive</li>
<li>Configuration (declarative) and actionable (imperative) logics mixed together</li>
<li>Highly configurable</li>
</ul>
<p><strong>Declartive style</strong>: adhere to some convention, specify additional configuration,
and let the tool decide what to do actually</p>
<ul>
<li><em>Examples</em>: Apache Maven</li>
<li>Separation between <em>what</em> to do and <em>how</em> to do it</li>
<li>Configuration limited by the provided options</li>
</ul>
</section><section>
<h2 id="hybrid-automators">Hybrid automators</h2>
<p>Create a <em>declarative infrastructure</em> upon an <em>imperative basis</em>, and
<em>allow easy access to the underlying machinery</em></p>
<p><strong>DSL</strong>s are helpful in this context: they can &ldquo;hide&rdquo; imperativity without ruling it out</p>
<p>Still, many challenges remain open:</p>
<ul>
<li>How to reuse the build logic?
<ul>
<li>within a project, and among projects</li>
</ul>
</li>
<li>How to structure multiple logical and interdependent parts?</li>
</ul>
</section><section>
<h1 id="gradle">Gradle</h1>
<p>A paradigmatic example of a hybrid automator:</p>
<ul>
<li>Written mostly in Java</li>
<li>with an outer Groovy DSL</li>
<li>&hellip;and, more recently, a Kotlin DSL</li>
</ul>
<h3 id="our-approach-to-gradle">Our approach to Gradle</h3>
<ul>
<li>We are <strong>not</strong> going to learn &ldquo;how to use Gradle&rdquo;</li>
<li>We are going to <em>learn Gradle</em></li>
</ul>
</section><section>
<h2 id="gradle-main-concepts">Gradle: main concepts</h2>
<ul>
<li><strong>Project</strong> &ndash; A collection of files comprising the software
<ul>
<li>A project can contain another project:</li>
<li>the container project is the <strong>root project</strong></li>
<li>the contained projects are <strong>subproject</strong>s</li>
</ul>
</li>
<li><strong>Build file</strong> &ndash; A special file, situated in the root directory of a project,
instructing Gradle on the actual organization of the project projects</li>
<li><strong>Dependency</strong> &ndash; A resource required by some operation.
<ul>
<li>May have dependencies itself</li>
<li>Dependencies of dependencies are called <em>transitive</em> dependencies</li>
</ul>
</li>
<li><strong>Configuration</strong> &ndash; A group of dependencies with <em>three roles</em>:
<ol>
<li><em>Declare</em> dependencies</li>
<li><em>Resolve</em> dependency declarations to actual artifacts/resources</li>
<li><em>Present</em> the dependencies to consumer in a suitable format</li>
</ol>
</li>
<li><strong>Task</strong> &ndash; An atomic operation on the project, which can
<ul>
<li>have input and output files</li>
<li>depend on other tasks (can be executed only if those are completed)</li>
</ul>
</li>
</ul>
</section><section>
<h2 id="gradle-from-scratch-empty-project">Gradle from scratch: empty project</h2>
<p>Let&rsquo;s start as empty as possible, just point your terminal to an empty folder and:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>gradle tasks
</code></pre></div><p>Stuff happens: if nothing is specified,
<br>
<em>Gradle considers the folder where it is invoked as a project</em>
<br>
<em>The project name matches the folder name</em></p>
<p>Let&rsquo;s understand what:
<br></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>Welcome to Gradle &lt;version&gt;!

Here are the highlights of this release:
 - Blah blah blah

Starting a Gradle Daemon (subsequent builds will be faster)
</code></pre></div><p>Up to there, it&rsquo;s just performance stuff:
Gradle uses a background service to speed up cacheable operations</p>
</section><section>
<h2 id="gradle-from-scratch-empty-project-1">Gradle from scratch: empty project</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>&gt; Task :tasks

------------------------------------------------------------
Tasks runnable from root project
------------------------------------------------------------

Build Setup tasks
-----------------
init - Initializes a new Gradle build.
wrapper - Generates Gradle wrapper files.
</code></pre></div><p>Some tasks exist already!
They are built-in.
Let&rsquo;s ignore them for now.</p>
</section><section>
<h2 id="gradle-from-scratch-empty-project-2">Gradle from scratch: empty project</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>Help tasks
----------
buildEnvironment - Displays all buildscript dependencies declared in root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
components - Displays the components produced by root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>. [incubating]
dependencies - Displays all dependencies declared in root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
dependencyInsight - Displays the insight into a specific dependency in root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
dependentComponents - Displays the dependent components of components in root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>. [incubating]
<span style="color:#038">help</span> - Displays a <span style="color:#038">help</span> message.
model - Displays the configuration model of root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>. [incubating]
outgoingVariants - Displays the outgoing variants of root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
projects - Displays the sub-projects of root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
properties - Displays the properties of root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
tasks - Displays the tasks runnable from root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
</code></pre></div><p>Informational tasks. Among them, the <code>tasks</code> task we just invoked</p>
</section><section>
<h2 id="gradle-configuration-vs-execution">Gradle: configuration vs execution</h2>
<p>It is time to create our first <em>task</em>
<br>
Create a <code>build.gradle.kts</code> file as follows:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.<span style="color:#369">register</span>(<span style="color:#d20;background-color:#fff0f0">&#34;brokenTask&#34;</span>) { <span style="color:#888">// creates a new task
</span><span style="color:#888"></span>    println(<span style="color:#d20;background-color:#fff0f0">&#34;this is executed at CONFIGURATION time!&#34;</span>)
}
</code></pre></div><p>Now launch gradle with <code>gradle brokenTask</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>gradle broken
this is executed at CONFIGURATION time!

BUILD SUCCESSFUL in 378ms
</code></pre></div><p>Looks ok, but it&rsquo;s <strong>utterly broken</strong></p>
</section><section>
<h2 id="gradle-configuration-vs-execution-1">Gradle: configuration vs execution</h2>
<p>Try launching <code>gradle tasks</code></p>
<ul>
<li>We do not expect our task to run, we are launching something else</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>❯ gradle tasks

&gt; Task :tasks

------------------------------------------------------------
Tasks runnable from root project
------------------------------------------------------------

this is executed at CONFIGURATION time!
Build Setup tasks
</code></pre></div><p><strong>Ouch!</strong></p>
<p><strong>Reason</strong>: the build script executes when Gradle is invoked, and <em>configures</em> tasks and dependencies.
<br>
Only later, when a task is invoked, it is <em>actually executed</em>
*</p>
</section><section>
<h2 id="gradle-configuration-vs-execution-2">Gradle: configuration vs execution</h2>
<p>Let&rsquo;s write a <em>correct</em> task</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.<span style="color:#369">register</span>(<span style="color:#d20;background-color:#fff0f0">&#34;helloWorld&#34;</span>) {
    doLast { <span style="color:#888">// This method takes as argument a Task.() -&gt; Unit
</span><span style="color:#888"></span>        println(<span style="color:#d20;background-color:#fff0f0">&#34;Hello, World!&#34;</span>)
    }
}
</code></pre></div><p>Execution with <code>gradle helloWorld</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>gradle helloWorld

&gt; Task :helloWorld
Hello, World!
</code></pre></div></section><section>
<h2 id="gradle-configuration-vs-execution-3">Gradle: configuration vs execution</h2>
<h3 id="why-two-separate-phases">Why two separate phases?</h3>
<p>Delaying the actual execution allows for a more <em>fine grained configuration</em>
<br>
This will be especially useful when <em>modifying existing behavior</em></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.<span style="color:#369">register</span>(<span style="color:#d20;background-color:#fff0f0">&#34;helloWorld&#34;</span>) {
    doLast { println(<span style="color:#d20;background-color:#fff0f0">&#34;Hello, World!&#34;</span>) }
}

tasks.<span style="color:#369">getByName</span>(<span style="color:#d20;background-color:#fff0f0">&#34;helloWorld&#34;</span>) { <span style="color:#888">// let&#39;s find an existing task 
</span><span style="color:#888"></span>    doFirst { <span style="color:#888">// Similar to doLast, but adds operations in head
</span><span style="color:#888"></span>        println(<span style="color:#d20;background-color:#fff0f0">&#34;Configured later, executed first.&#34;</span>)
    }  
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>gradle helloWorld

&gt; Task :helloWorld
Configured later, executed first.
Hello, World!
</code></pre></div></section><section>
<h2 id="gradle-task-types">Gradle: task types</h2>
<p>Gradle offers some facilities to make it writing new tasks easier
<br>
An example is the <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/Exec.html"><code>org.gradle.api.Exec</code></a> task type, representing a command to be executed on the underlying command line</p>
<p>At task registration time, it is possible to specify the task type.
<br>
Any <code>open class</code> implementing <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html"><code>org.gradle.api.Task</code></a> can be instanced</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">org.gradle.internal.jvm.Jvm</span> <span style="color:#888">// Jvm is part of the Gradle API
</span><span style="color:#888"></span>tasks.<span style="color:#369">register</span>&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;printJavaVersion&#34;</span>) { <span style="color:#888">// Do you Recognize this? inline function with reified type!
</span><span style="color:#888"></span>    <span style="color:#888">// Configuration action is of type T.() -&gt; Unit, in this case Exec.T() -&gt; Unit
</span><span style="color:#888"></span>    val javaExecutable = Jvm.<span style="color:#369">current</span>().<span style="color:#369">javaExecutable</span>.<span style="color:#369">absolutePath</span> 
    commandLine( <span style="color:#888">// this is a method of class org.gradle.api.Exec
</span><span style="color:#888"></span>        javaExecutable, <span style="color:#d20;background-color:#fff0f0">&#34;-version&#34;</span>
    )
    <span style="color:#888">// There is no need of doLast / doFirst, actions are already configured
</span><span style="color:#888"></span>    <span style="color:#888">// Still, we may want to do something before or after the task has been executed
</span><span style="color:#888"></span>    doLast { println(<span style="color:#d20;background-color:#fff0f0">&#34;$javaExecutable invocation complete&#34;</span>) }
    doFirst { println(<span style="color:#d20;background-color:#fff0f0">&#34;Ready to invoke $javaExecutable&#34;</span>) }
}
</code></pre></div><pre><code>&gt; Task :printJavaVersion
Ready to invoke /usr/lib/jvm/java-11-openjdk/bin/java
openjdk version &quot;11.0.8&quot; 2020-07-14
OpenJDK Runtime Environment (build 11.0.8+10)
OpenJDK 64-Bit Server VM (build 11.0.8+10, mixed mode)
/usr/lib/jvm/java-11-openjdk/bin/java invocation complete
</code></pre></section><section>
<h2 id="gradle-principle-of-automation">Gradle: principle of automation</h2>
<p>Let&rsquo;s try something more involved: compiling some Java source located in <code>src</code>.
<br></p>
<h4 id="principle"><strong>PRINCIPLE</strong></h4>
<blockquote>
<p><em>If you know how to do it, then you can instruct a machine to do it</em></p>
</blockquote>
<p>Compiling a Java source is just matter of invoking the <code>javac</code> compiler:</p>
<ul>
<li>Passing the files to be compiled</li>
<li>Passing an appropriate classpath where to look for dependencies</li>
<li>Passing where to put generated files</li>
</ul>
<p><em>Once you learn how some product is built, and you know how to build it by hand</em>
<br>
<strong>you have all the knowledge required to automate its construction</strong></p>
</section><section>
<h2 id="gradle-compiling-from-scratch">Gradle: compiling from scratch</h2>
<p>Let&rsquo;s compile a simple <code>src/HelloWorld.java</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">HelloWorld</span> {
    <span style="color:#080;font-weight:bold">public</span> <span style="color:#080;font-weight:bold">static</span> <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">main</span>(String... args) {
        System.<span style="color:#369">out</span>.<span style="color:#369">println</span>(<span style="color:#d20;background-color:#fff0f0">&#34;Hello, World!&#34;</span>);
    }
}
</code></pre></div><p>Build logic:</p>
<ol>
<li>Find the sources to be compiled</li>
<li>If any, find <code>javac</code></li>
<li>Invoke <code>javac -d destination &lt;files&gt;</code></li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">org.gradle.internal.jvm.Jvm</span>
tasks.<span style="color:#369">register</span>&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;compileJava&#34;</span>) {
    val sources = findSources() <span style="color:#888">// 
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (sources.<span style="color:#369">isNotEmpty</span>())  { <span style="color:#888">// If the folder exists and there are files
</span><span style="color:#888"></span>        val javacExecutable = Jvm.<span style="color:#369">current</span>().<span style="color:#369">javacExecutable</span>.<span style="color:#369">absolutePath</span> <span style="color:#888">// Use the current JVM&#39;s javac
</span><span style="color:#888"></span>        commandLine(
            <span style="color:#d20;background-color:#fff0f0">&#34;$javacExecutable&#34;</span>,
            <span style="color:#d20;background-color:#fff0f0">&#34;-d&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;$buildDir/bin&#34;</span>, <span style="color:#888">// destination folder: the output directory of Gradle, inside &#34;bin&#34;
</span><span style="color:#888"></span>            *sources
        )
    }
    <span style="color:#888">// the task&#39;s doLast is inherited from Exec
</span><span style="color:#888"></span>}
</code></pre></div></section><section>
<h2 id="gradle-compiling-from-scratch-1">Gradle: compiling from scratch</h2>
<p>Here is the <code>findSources()</code> function:</p>
<ul>
<li>Pure Kotlin</li>
<li>Single expression</li>
<li>Fluent safe call chaining</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findSources</span>(): Array&lt;String&gt; = projectDir <span style="color:#888">// From the project
</span><span style="color:#888"></span>    .listFiles { it: File -&gt; it.isDirectory &amp;&amp; it.name == <span style="color:#d20;background-color:#fff0f0">&#34;src&#34;</span> } <span style="color:#888">// Find a folder named &#39;src&#39;
</span><span style="color:#888"></span>    ?.firstOrNull() <span style="color:#888">// If it&#39;s not there we&#39;re done
</span><span style="color:#888"></span>    ?.walk() <span style="color:#888">// If it&#39;s there, iterate all its content (returns a Sequence&lt;File&gt;)
</span><span style="color:#888"></span>    ?.filter { it.extension == <span style="color:#d20;background-color:#fff0f0">&#34;java&#34;</span> } <span style="color:#888">// Pick all Java files
</span><span style="color:#888"></span>    ?.map { it.absolutePath } <span style="color:#888">// Map them to their absolute path
</span><span style="color:#888"></span>    ?.toList() <span style="color:#888">// Sequences can&#39;t get converted to arrays, we must go through lists
</span><span style="color:#888"></span>    ?.toTypedArray() <span style="color:#888">// Convert to Array&lt;String&gt;
</span><span style="color:#888"></span>    ?: emptyArray() <span style="color:#888">// Yeah if anything&#39;s missing there are no sources
</span></code></pre></div><p>Execution:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>gradle compileJava

BUILD SUCCESSFUL in 693ms
</code></pre></div><p>Compiled files are in <code>build/bin</code>!</p>
</section><section>
<h2 id="gradle-dependency-management">Gradle: dependency management</h2>
<p>Dependency management in Gradle depends from two fundamental concepts:</p>
<ul>
<li><strong>Dependency</strong>, a resource of some kind, possibly having other (<em>transitive</em>) dependencies</li>
<li><strong>Configuration</strong>, a <em>resolvable</em> (mappable to actual resources) set of dependencies</li>
</ul>
<p>Let&rsquo;s see a use case: compiling a Java source with a dependency</p>
<ul>
<li>In <code>javac</code> terms, we need to feed some jars to the <code>-cp</code> flag of the compiler</li>
<li>In Gradle (automation) terms, we need:
<ul>
<li>a <em>configuration</em> representing the compile classpath</li>
<li>one <em>dependency</em> for each library we need to compile</li>
</ul>
</li>
</ul>
</section><section>
<h2 id="gradle-dependency-management-1">Gradle: dependency management</h2>
<p>Conceptually, we want something like:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// Gradle way to create a configuration
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">compileClasspath</span> <span style="color:#080;font-weight:bold">by</span> configurations.creating <span style="color:#888">// Delegation!
</span><span style="color:#888"></span>dependencies {
    forEachLibrary { <span style="color:#888">// this function does not exist, unfortunate...
</span><span style="color:#888"></span>        compileClasspath(files(it))
    }
}
</code></pre></div><p>To be consumed by our improved compile task:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.register&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;compileJava&#34;</span>) {
    <span style="color:#888">// Resolve the classpath configuration (in general, files could be remote and need fetching)
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">classpathFiles</span> = compileClasspath.resolve()
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">sources</span> = findSources() <span style="color:#888">// Find sources
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (sources != <span style="color:#080;font-weight:bold">null</span>)  {
        <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">javacExecutable</span> = Jvm.current().javacExecutable.absolutePath
        <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">separator</span> = <span style="color:#080;font-weight:bold">if</span> (Os.isFamily(Os.FAMILY_WINDOWS)) <span style="color:#d20;background-color:#fff0f0">&#34;;&#34;</span> <span style="color:#080;font-weight:bold">else</span> <span style="color:#d20;background-color:#fff0f0">&#34;:&#34;</span> <span style="color:#888">// Deal with Windows conventions
</span><span style="color:#888"></span>        commandLine(
            <span style="color:#d20;background-color:#fff0f0">&#34;$javacExecutable&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;-cp&#34;</span>, classpathFiles.joinToString(separator = separator),
            <span style="color:#d20;background-color:#fff0f0">&#34;-d&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;bin&#34;</span>, *sources
        )
    }
}
</code></pre></div><p>We just need to write <code>forEachLibrary</code>, but that is just a Kotlin exercise&hellip;</p>
</section><section>
<h2 id="micro-exercise-in-kotlin">Micro exercise in Kotlin</h2>
<p>&hellip;not particularly difficult to solve:</p>
<ol>
<li>It&rsquo;s just something we need to do for each library</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// In the context of a DependencyHandlerScope
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">DependencyHandlerScope</span>.forEachLibrary(todo: DependencyHandlerScope.(String) -&gt; Unit) {
    findLibraries().forEach { <span style="color:#888">// For each library (function to be written)
</span><span style="color:#888"></span>        todo(it) <span style="color:#888">// this.todo(it) -&gt; invoke todo on this passing the library
</span><span style="color:#888"></span>    }
}
</code></pre></div><ol start="2">
<li><code>findLibraries()</code> is similar to <code>findSources()</code>, let&rsquo;s refactor:</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findSources</span>() = findFilesIn(<span style="color:#d20;background-color:#fff0f0">&#34;src&#34;</span>).withExtension(<span style="color:#d20;background-color:#fff0f0">&#34;java&#34;</span>) <span style="color:#888">// OK now we need findFiles()
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findLibraries</span>() = findFilesIn(<span style="color:#d20;background-color:#fff0f0">&#34;lib&#34;</span>).withExtension(<span style="color:#d20;background-color:#fff0f0">&#34;jar&#34;</span>) <span style="color:#888">// And we also need a way to invoke withExtension
</span></code></pre></div><ol start="3">
<li>Let&rsquo;s use an intermediate class representing a search on a folder:</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findFilesIn</span>(directory: String) = FinderInFolder(directory)
<span style="color:#080;font-weight:bold">data</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">FinderInFolder</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">directory</span>: String) {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">withExtension</span>(extension: String): Array&lt;String&gt; = TODO()
}
<span style="color:#888">// Now it compiles! We just need to write the actual method, but that&#39;s easy
</span></code></pre></div></section><section>
<h2 id="micro-exercise-in-kotlin-1">Micro exercise in Kotlin</h2>
<p>Complete solution:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">data</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">FinderInFolder</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">directory</span>: String) {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">withExtension</span>(extension: String): Array&lt;String&gt; = projectDir
        .listFiles { it: File -&gt; it.isDirectory &amp;&amp; it.name == directory }
        ?.firstOrNull()
        ?.walk()
        ?.filter { it.extension == extension }
        ?.map { it.absolutePath }
        ?.toList()
        ?.toTypedArray()
        ?: emptyArray()
}
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findFilesIn</span>(directory: String) = FinderInFolder(directory)
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findSources</span>() = findFilesIn(<span style="color:#d20;background-color:#fff0f0">&#34;src&#34;</span>).withExtension(<span style="color:#d20;background-color:#fff0f0">&#34;java&#34;</span>)
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findLibraries</span>() = findFilesIn(<span style="color:#d20;background-color:#fff0f0">&#34;lib&#34;</span>).withExtension(<span style="color:#d20;background-color:#fff0f0">&#34;jar&#34;</span>)
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">DependencyHandlerScope</span>.forEachLibrary(todo: DependencyHandlerScope.(String) -&gt; Unit) {
    findLibraries().forEach { todo(it) }
}

</code></pre></div></section><section>
<h2 id="gradle-task-dependencies">Gradle: task dependencies</h2>
<p>Next step: we can compile, why not executing the program as well?</p>
<ol>
<li>Let&rsquo;s define a <code>runtimeClasspath</code> configuration
<ul>
<li>&ldquo;inherits&rdquo; from <code>compileClasspath</code></li>
<li>In general we may need stuff at runtime that we don&rsquo;t need at compile time
<ul>
<li>E.g. stuff loaded via reflection</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">runtimeClasspath</span> <span style="color:#080;font-weight:bold">by</span> configurations.creating {
    extendsFrom(compileClasspath) <span style="color:#888">// Built-in machinery to say that one configuration is another &#34;plus stuff&#34;
</span><span style="color:#888"></span>}
</code></pre></div><ol start="2">
<li>Let&rsquo;s write the task</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.register&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;runJava&#34;</span>) {
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">classpathFiles</span> = runtimeClasspath.resolve()
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">mainClass</span> = <span style="color:#d20;background-color:#fff0f0">&#34;PrintException&#34;</span> <span style="color:#888">// Horribly hardcoded, we must do something
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">javaExecutable</span> = Jvm.current().javaExecutable.absolutePath
    commandLine(
            <span style="color:#d20;background-color:#fff0f0">&#34;$javaExecutable&#34;</span>,
            <span style="color:#d20;background-color:#fff0f0">&#34;-cp&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;$buildDir/bin/$separator${classpathFiles.joinToString(separator = separator)}&#34;</span>,
            mainClass
    )
}
</code></pre></div></section><section>
<h2 id="gradle-task-dependencies-1">Gradle: task dependencies</h2>
<p>Let&rsquo;s run it!</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>❯ gradle runJava

&gt; Task :runJava FAILED
Error: Could not find or load main class PrintException
Caused by: java.lang.ClassNotFoundException: PrintException

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed <span style="color:#080;font-weight:bold">for</span> task <span style="color:#d20;background-color:#fff0f0">&#39;:runJava&#39;</span>.
&gt; Process <span style="color:#d20;background-color:#fff0f0">&#39;command &#39;</span>/usr/lib/jvm/java-11-openjdk/bin/java<span style="color:#d20;background-color:#fff0f0">&#39;&#39;</span> finished with non-zero <span style="color:#038">exit</span> value <span style="color:#00d;font-weight:bold">1</span>
</code></pre></div><p>$\Rightarrow$ The code was not compiled!</p>
<ul>
<li>We need <code>runJava</code> to run after <code>compileJava</code></li>
<li>One task depends on another!</li>
</ul>
</section><section>
<h2 id="gradle-task-dependencies-2">Gradle: task dependencies</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// Let&#39;s get a reference to the task
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">compileJava</span> = tasks.register&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;compileJava&#34;</span>) {
    ...
}
tasks.register&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;runJava&#34;</span>) {
    ...
    dependsOn(compileJava) <span style="color:#888">// runJava can run only if compileJava has been run
</span><span style="color:#888"></span>}

</code></pre></div><p>Run now:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#369">TERM</span>=dumb gradle runJava
&gt; Task :compileJava

&gt; Task :runJava
java.lang.IllegalStateException
        at PrintException.main(PrintException.java:5)

Just printed a stacktrace, I<span style="color:#a61717;background-color:#e3d2d2">&#39;</span>m fine actually

BUILD SUCCESSFUL in 775ms
<span style="color:#00d;font-weight:bold">2</span> actionable tasks: <span style="color:#00d;font-weight:bold">2</span> executed
</code></pre></div></section><section>
<h2 id="build-automation-dependencies-everywhere">Build automation: dependencies everywhere</h2>
<p>Dependencies permeate the world of build automation.</p>
<ul>
<li>At the <em>&ldquo;task&rdquo;</em> level
<ul>
<li>Compile dependencies</li>
<li>Runtime dependencies</li>
</ul>
</li>
<li>At the <em>&ldquo;build&rdquo;</em> level
<ul>
<li>Phases of the lifecycle (<em>configurations</em> in Gradle) depend on other phases</li>
<li><em>Tasks</em> depend on other tasks</li>
</ul>
</li>
</ul>
<p>$\Rightarrow$ <em>at the <strong>global</strong> level as well!</em></p>
<p><em>no guarantee</em>  that automation written with some tool at version <code>X</code>, will work at version <code>Y</code>!</p>
</section><section>
<h2 id="the-gradle-wrapper">The Gradle wrapper</h2>
<ul>
<li>A global dependency on the build tool is <strong>hard to capture</strong></li>
<li>Often, it becomes a <em>prerequisite expressed in natural language</em>
<ul>
<li>e.g., &ldquo;you need Maven 3.6.1 to build this software&rdquo;</li>
</ul>
</li>
<li><em>Critical</em> issues when different pieces of the same system depend on different build tool versions</li>
</ul>
<p>Gradle proposes a (partial) solution with the so-called <em>Gradle wrapper</em></p>
<ul>
<li><em>A minimal program</em> that simply downloads the version of gradle written in a configuration file</li>
<li><em>Generable</em> with the built-in task <code>wrapper</code>
<ul>
<li><code>gradle wrapper --gradle-version=&lt;VERSION&gt;</code></li>
</ul>
</li>
<li>Prepares scripts for bash and cmd to run Gradle at the specified version
<ul>
<li><code>gradlew</code></li>
<li><code>gradlew.bat</code></li>
</ul>
</li>
</ul>
<p>The Gradle wrapper is <em>the correct way</em> to use gradle, and we&rsquo;ll be using it from now on.</p>
</section><section>
<h2 id="cleaning-up">Cleaning up</h2>
<p>A source of failures when building is <em>dirty status</em>.
<br>
For istance, in the previous example, before we introduced a dependency between tasks:</p>
<ul>
<li>clean execution fails</li>
<li>execution after a <em>manual</em> execution of compile works
<ul>
<li><strong>false positive!</strong></li>
</ul>
</li>
</ul>
<p>We need a way to start clean.
<br>
This usually involves cleaning up the build directory - not so hard in our example</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.register(<span style="color:#d20;background-color:#fff0f0">&#34;clean&#34;</span>) { <span style="color:#888">// A generic task is fine
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (!buildDir.deleteRecursively()) {
        <span style="color:#080;font-weight:bold">throw</span> IllegalStateException(<span style="color:#d20;background-color:#fff0f0">&#34;Cannot delete $buildDir&#34;</span>)
    }
}
</code></pre></div></section><section>
<h2 id="build-hierarchies">Build hierarchies</h2>
<p>Sometimes projects are <em>modular</em>
<br>
Where a module is a sub-project with a clear identity, possibly reusable elsewhere</p>
<p>Examples:</p>
<ul>
<li>A smartphone application with:
<ul>
<li>A common library</li>
<li>A software that uses such library for the actual app</li>
</ul>
</li>
<li>Bluetooth control software comprising:
<ul>
<li>Platform-specific drivers</li>
<li>A platform-agnostic bluetooth API and service</li>
<li>A CLI interface to the library</li>
<li>A Graphical interface</li>
</ul>
</li>
</ul>
<p>Modular software <em>simplifies maintenance</em> and <em>improves understandability</em>
<br>
Modules may <strong>depend</strong> on other modules
<br>
Some build tasks of some module may require build tasks <em>of other modules</em> to be complete before execution</p>
</section><section>
<p>subprojects (lib + app)
* Hierarchial organization
* naming a project</p>
<p>Write a custom Task for compilation
@Input e @Output
Continuous build
Write a custom task for Execution</p>
<ul>
<li>Isolation of imperativity</li>
<li>Declarativity via DSLs
concept of plugin
the kotlin plugin</li>
<li>jvm variant</li>
<li>with its configurations
our &ldquo;plugin for java&rdquo;
testing a plugin (kotest + Gradle api + classpath trick)
some existing plugins</li>
<li>detekt</li>
<li>ktlint</li>
<li>jacoco</li>
<li>refreshVersions</li>
</ul>
</section>

  


</div>
      

    </div>
<script type="text/javascript" src=/Course-Laboratory-of-Software-Systems/reveal-hugo/object-assign.js></script>

<a href="/Course-Laboratory-of-Software-Systems/reveal-js/css/print/" id="print-location" style="display: none;"></a>
<script type="text/javascript">
  var printLocationElement = document.getElementById('print-location');
  var link = document.createElement('link');
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = printLocationElement.href + (window.location.search.match(/print-pdf/gi) ? 'pdf.css' : 'paper.css');
  document.getElementsByTagName('head')[0].appendChild(link);
</script>

<script type="application/json" id="reveal-hugo-site-params">{"height":"100%","pdfseparatefragments":false,"theme":"white","width":"100%"}</script>
<script type="application/json" id="reveal-hugo-page-params">{"custom_theme":"custom-theme.scss","custom_theme_compile":true,"custom_theme_options":{"enablesourcemap":true,"targetpath":"css/custom-theme.css"},"transition":"slide","transition_speed":"fast"}</script>

<script src="/Course-Laboratory-of-Software-Systems/reveal-js/js/reveal.js"></script>

<script type="text/javascript">
  
  
  function camelize(map) {
    if (map) {
      Object.keys(map).forEach(function(k) {
        newK = k.replace(/(\_\w)/g, function(m) { return m[1].toUpperCase() });
        if (newK != k) {
          map[newK] = map[k];
          delete map[k];
        }
      });
    }
    return map;
  }
  
  var revealHugoDefaults = { center: true, controls: true, history: true, progress: true, transition: "slide" };
  var revealHugoSiteParams = JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);
  var revealHugoPageParams = JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);
  
  var options = Object.assign({},
    camelize(revealHugoDefaults),
    camelize(revealHugoSiteParams),
    camelize(revealHugoPageParams));
  Reveal.initialize(options);
</script>


  
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/markdown/marked.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/markdown/markdown.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/highlight/highlight.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/zoom-js/zoom.js"></script>
  
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/notes/notes.js"></script>



    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      }
    };
</script>

<script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

    
  </body>
</html>
